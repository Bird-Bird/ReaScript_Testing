noindex: true
version: 0.99
authot: BirdBird
about: The JSFX recorder for Global Sampler.
changelog: Development version.
options:gmem=BB_Resampler
desc:BirdBird Global Resampler Recorder

in_pin:left input
in_pin:right input
out_pin:left output
out_pin:right output

@init
ext_noinit = 1;
max_mem = 8000000;
max_display = 10000;
max_secs = (max_mem - max_display)/srate;
max_secs *= 0.5;

len_in_secs = 60;
len_in_secs > max_secs ? (
  len_in_secs = floor(max_secs);
);

size = len_in_secs * srate;
disp_temp_buf = 0;
gmem_reserved = 10;

//gmem --> [0-->gmem_reserved - 1] are for variables
gmem[0] = len_in_secs;
gmem[1] = gmem_reserved;
//gmem[2] --> pauses write mode if 1 (script controlled)
//gmem[3] --> currently playing
//gmem[4] --> playback start position
//gmem[5] --> playback length
//gmem[6] --> current counter position
//gmem[7] --> display size
//gmem[8] --> display buffer index

@slider

@sample
//Handle recording boundary
play_state != last_play_state ? (
  play_state != 0 ? (
    gmem[3] = 1;
    gmem[4] = counter;
    play_start = play_position;

    play_len = 0;
    playback = 1;
  );
  play_state == 0 ? (
    gmem[3]= 0;
    gmem[5] = play_len;
    playback = 0;
  );
);
last_play_state = play_state;

playback == 1 ? (
  gmem[5] = play_len;
  play_len += 1/srate;
  play_len > len_in_secs ? (
    play_len = len_in_secs;
  );
);

//Record audio
gmem[2] == 0 ? (
  l_index = counter + gmem_reserved;
  gmem[l_index] = spl0;
  gmem[l_index + size] = spl1;
  gmem[6] = counter;
  
  //Anti-aliased waveform buffer
  timer = time_precise();
  disp_val = (spl0 + spl1)/2;
  
  disp_buf_size = gmem[7];
  disp_buf = gmem_reserved + (size*2) + 1;
  gmem[8] = disp_buf;

  //RESAMPLE DISPLAY BUFFER
  timer - last_disp_resample > 0 && disp_buf_size != last_disp_buf_size ? (
    //COPY TO TEMP BUFFER
    i = 0;
    while(i < last_disp_buf_size) (
      disp_temp_buf[i] = gmem[disp_buf + i];
      gmem[disp_buf + i] = 0;
      i = i+1;
    );
    
    //RESAMPLE FROM TEMP BUFFER
    i = 0;
    while(i < disp_buf_size) (
      t_index = floor((i/disp_buf_size)*last_disp_buf_size);
      gmem[disp_buf + i] = disp_temp_buf[t_index];
      i = i+1;
    );
    
    //FLUSH DISPLAY BUFFER
    i = 0;
    disp_timestamp_buf = disp_buf + disp_buf_size*2 + 1;
    while(i < last_disp_buf_size) (   
      disp_timestamp_buf[i] = 0;
      i = i+1;
    );

    last_disp_resample = timer;
    last_disp_buf_size = disp_buf_size;
  );
  
  counter_norm = counter/size;
  disp_counter = floor(counter_norm*disp_buf_size);
  
  disp_timestamp_buf = disp_buf + disp_buf_size*2 + 1;
  disp_timestamp = disp_timestamp_buf[disp_counter];

  l_disp_val = gmem[disp_buf + disp_counter];
  abs(disp_val) > abs(l_disp_val) || timer - disp_timestamp > len_in_secs - 0.1 ? ( 
    gmem[disp_buf + disp_counter] = disp_val;
    disp_timestamp_buf[disp_counter] = timer;
  );
  
  //Increment writer
  counter += 1;
  counter == size ? (
    counter = counter % size;
  );
);
